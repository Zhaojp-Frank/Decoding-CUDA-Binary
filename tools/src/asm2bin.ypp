%{
#include <fstream>
#include <iostream>
#include <limits.h>
#include <stdio.h>
#include <string.h>
#include "binary.hpp"
#include "cfghelpers.hpp"
#include "common.hpp"
#include "cudacommon.hpp"
#include "elfmanip.hpp"
#include "output.hpp"
#include "asm2bin.hpp"
using namespace std;

//Note: if program throws "memory exhausted" error, increase YYMAXDEPTH:
#define YYMAXDEPTH 90000

int _shared_memory = -1; //amount of shared memory allocated per thread block, or -1
int _frame_size = -1; //frame size as specified in ELF, or -1
int _min_stack_size = -1; //max stack size as specified in ELF, or -1
int _max_stack_size = -1; //min stack size as specified in ELF, or -1
char* _kernel_name = 0; //kernel function's name as specified in ELF
char** _function_names = 0; //names of subroutines specified in ELF
int _num_functions = 0; //number of subroutines specified in ELF
node * _functions = 0; //locations of subroutines in executable GPU code
int _arch = 0; //architecture; for Compute Capability 2.1 this has value 21, etcetera
int _cuobjdump_version = 0; //version of cuobjdump used to extract assembly code

//Used to keep track of instruction types during parsing:
bool currentDouble = false;
bool current32I = false;

int _num_registers = 0;//number of registers the assembly code uses (equal to highest register ID + 1)

node * _blocks;//The list of basic blocks generated by the parser

//Variables used during parsing:
blockNode * _currentBlock;//The basic block currently in use by the parser
int _counter = 0;//The current 'line number'; the instruction's address divided by 8
int _addr = 0;//The current address during parsing
char * _lastLabel = 0;//The label to be applied to the instruction being parsed
instruction * _lastInstruction = 0;//The last instruction parsed
node * _lastBlock = 0;//The node for the last block added to the blocks list
instruction * _lastSCHI = 0;
char _lastSCHIVal;
char _last_guard = 'z';//if the last predicate guard was @P2, this is set to '2', etc.
bool _last_guard_neg = false;//true when predicate guard is of form @!Pn for any n
bool _just_branched = false;//set to nonzero when branch instructions are parsed; signals new basic block
int _tag = 1;//used to help avoid infinite recursion; don't reuse values!

int yylex();
int yylex_destroy();
void yyerror(const char * s);
extern FILE * yyin;
%}

%error-verbose
%union {
		token token_;
		node node_;
	}

%token <token_> CC PR SB_OPERAND CHANNEL TEXOP GUARD MOD CONST MEMORY
%token <token_> HEXVAL REG PREDICATE SPECIALNAME SPECIALID DECIMAL LINENUMBER PLUSINF NEGINF BITLIST
%token <token_> PLUSQNAN PLUSSNAN
%token <token_> MOV MOV32I LD LDU LDL LDS LDC ST STL STS LDLK LDSLK STUL STSUL FADD FADD32I FMUL FMUL32I FFMA FSET FSETP DSETP FCMP MUFU DADD DMUL DFMA IADD IADD32I IMNMX IMUL IMUL32I IMAD ISCADD ISET ISETP ICMP I2F I2I F2I F2F LOP LOP32I SHL SHR BFE BFI SEL SCHI SSY BRA BRX PCNT CONT PBK BRK CAL RET EXIT NOP BAR BPT B2R S2R PSETP PSET FLO P2R R2P TEX TEXDEPBAR RRO PRMT VADD DMNMX FMNMX RED VOTE POPC MEMBAR STSCUL LEPC CSETP ISCADD32I VMNMX TLD SHF FCHK ATOM CCTL
%token <token_> XMAD SYNC STG IADD3 VABSDIFF DEPBAR LOP3 TLDS TEXS LEA DSET
%token <token_> PHI
%token <token_> BINCODE
%token <token_> ISUB LDG LD_LDU
%token <token_> JCAL
%token <token_> SHFL
%token <token_> LABEL LABEL_OP INLINE_SCHI_VALUE SCHI50
%token <token_> COMMENT METADATA_SHAREDMEM METADATA_FRAME_SIZE METADATA_MIN_STACK_SIZE METADATA_MAX_STACK_SIZE METADATA_KERNELNAME METADATA_FUNCTIONCOUNT METADATA_FUNCTIONNAME METADATA_ARCH METADATA_CUOBJDUMP

%type <node_> instruction mods operand operands predicate_guard

%start assemblyfile

%%
assemblyfile :	program
	|	metadata assemblyfile
;

metadata :	METADATA_SHAREDMEM
		{
			_shared_memory = strtol($1.lexeme, 0, 0);
		}
	|	METADATA_FRAME_SIZE
		{
			_frame_size = strtol($1.lexeme, 0, 0);
		}
	|	METADATA_MIN_STACK_SIZE
		{
			_min_stack_size = strtol($1.lexeme, 0, 0);
		}
	|	METADATA_MAX_STACK_SIZE
		{
			_max_stack_size = strtol($1.lexeme, 0, 0);
		}
	|	METADATA_KERNELNAME
		{
			_kernel_name = $1.lexeme;
		}
	|	METADATA_FUNCTIONCOUNT
		{
			_function_names = (char**) malloc(strtol($1.lexeme, 0, 0) * sizeof(char*));
		}
	|	METADATA_FUNCTIONNAME
		{
			_function_names[_num_functions] = $1.lexeme;
			_num_functions++;
		}
	|	METADATA_ARCH
		{
			_arch = atoi($1.lexeme);
		}
	|	METADATA_CUOBJDUMP
		{
			_cuobjdump_version = atoi($1.lexeme);
		}
;

program :	program statements
	|	/* empty */
;

statements :	statement 
		{
			currentDouble = false;
			current32I = false;
			
			//Increment line count:
			_counter++;
			
			if(_just_branched) {//We're at the end of a basic block
				_just_branched = false;
				_currentBlock->last = _counter - 1;
				
				//Set up next basic block:
				blockNode * newBlock;
				initBlock(&newBlock);
				newBlock->first = _counter;
				newBlock->address = _addr;
				newBlock->id = _currentBlock->id + 1;
				
				//Add new block as successor to old block, if appropriate
				//Note: the '_currentBlock->guarded' condition results in extra successors, but makes analysis easier.
				if(_currentBlock->guarded || _currentBlock->end == end_generic || _currentBlock->end == end_call) {
					addNode(&_currentBlock->forward, (void*)newBlock, &blockorder);
					if(_currentBlock->end == end_generic || _currentBlock->end == end_call) {
						addNode(&newBlock->predecessors, (void*)_currentBlock, &blockorder);
					}
				}
				
				//Add old block to list, set _currentBlock to the new block
				if(_lastBlock) {
					addLast(&_lastBlock, (void*)_currentBlock);
					_lastBlock = _lastBlock->next;
				}
				else {
					addLast(&_blocks, (void*)_currentBlock);
					_lastBlock = _blocks;
				}
				_currentBlock = newBlock;
			}
		}
	|	LABEL
		{
			_lastLabel = $1.lexeme;
		}
	|	INLINE_SCHI_VALUE
		{
			int schival = strtoul($1.lexeme, NULL, 16);
			free($1.lexeme);
			if(_arch >= 30 && _arch < 50) {
				_lastInstruction->SCHIVal = schival;
			} else if(_arch >= 50 && _arch < 70) {
				_lastInstruction->SCHIVal = schival & 0x1f;
				schival = schival >> 5;
				_lastInstruction->depBarrierW = schival & 0x7;
				schival = schival >> 3;
				_lastInstruction->depBarrierR = schival & 0x7;
				schival = schival >> 3;
				_lastInstruction->depBarrierMask = schival & 0x3f;
				
				//NOTE: I ignore any register-reuse bits here
			} else {
				cerr << "SANITY CHECK ERROR py~216.\n";
				cerr << "\tUnsupported architecture.\n";
			}
		}
	|	SCHI50 
		HEXVAL {_lastInstruction->SCHIVal = strtoul($2.lexeme, NULL, 16);} 
		DECIMAL {_lastInstruction->depBarrierW = atoi($4.lexeme);} 
		DECIMAL {_lastInstruction->depBarrierR = atoi($6.lexeme);} 
		DECIMAL {
			if(strlen($8.lexeme) != 6) {
				cerr << "SANITY CHECK ERROR py~249: invalid bitmask for inline SCHI 5.0.\n";
				cerr << "\tThere should be a string of exactly six 1s/0s to indicate barriers.\n";
			}
			_lastInstruction->depBarrierMask = 0;
			for(int x = 0; x < 6; x++) {
				if($8.lexeme[x] == '1') {
					_lastInstruction->depBarrierMask |= (1 << x);
				}
			}
		}
;

statement	:	predicate_guard
			{
				//Analyze the predicate guard to decide basic-block layout:
				int temp = 0;
				operand * pred = (operand*) $1.value;
				if((pred->properties == prop_not) != _last_guard_neg) {//previous guard had opposite sign of this one
					//if(_last_guard == pred->val1 && !_currentBlock->force_guard) {//same predicate
					//	temp = 3;//newblock,force_guard = true
					//}
					//else {//different predicate
						temp = 1;//newblock
					//}
				}
				else if(_last_guard != (long long)pred->val1) {//previous guard had different predicate
					temp = 1;//newblock
				}
				
				if(temp) {//new basic block
					//The if condition here avoids causing basic blocks that are empty, or that
					// only contain a SCHI instruction:
					if(_currentBlock->first != _counter && (_currentBlock->first + 1 < _counter ||
					opcode_SCHI != ((instruction*)_currentBlock->instructions->value)->op)) {
						//Create new basic block, put it into _currentBlock:
						_currentBlock->last = _counter - 1;
						blockNode * newBlock;
						initBlock(&newBlock);
						newBlock->first = _counter;
						newBlock->address = _addr;
						newBlock->id = _currentBlock->id + 1;
						if(_currentBlock->guarded || _currentBlock->end == end_generic) {//new block is successor of old block
							addNode(&_currentBlock->forward, (void*)newBlock, &blockorder);
							addNode(&newBlock->predecessors, (void*)_currentBlock, &blockorder);
						}
						if(_lastBlock) {
							addLast(&_lastBlock, (void*)_currentBlock);
							_lastBlock = _lastBlock->next;
						}
						else {
							addLast(&_blocks, (void*)_currentBlock);
							_lastBlock = _blocks;
						}
						_currentBlock = newBlock;
					}
					
					//If the two blocks have the same predicate but different signs, set force_guard to
					// remember that control flow here is forced into one of the two blocks:
					if(temp > 1) {
						_currentBlock->force_guard = true;
					}
				}
				
				//Remember current predicate guard, and whether it is negated:
				_last_guard_neg = (pred->properties == prop_not);
				_last_guard = pred->val1;
			}
			instruction
			{
				instruction * i = (instruction*) $3.value;
				i->address = _addr;
				i->line = _counter;
				i->original_line = _counter;
				
				//Set instruction's metadata regarding the predicate guard:
				_currentBlock->guarded = true;
				i->guard = (operand*) $1.value;
				
				//Add instruction to basic block:
				if(_lastSCHI && _lastSCHIVal < _lastSCHI->num_operands) {
					int schival = _lastSCHI->operands[(int)_lastSCHIVal]->val1;
					if(_arch >= 30 && _arch < 50) {
						i->SCHIVal = schival;
					} else if(_arch >= 50 && _arch < 70) {
						i->SCHIVal = schival & 0x1f;
						schival = schival >> 5;
						i->depBarrierW = schival & 0x7;
						schival = schival >> 3;
						i->depBarrierR = schival & 0x7;
						schival = schival >> 3;
						i->depBarrierMask = schival & 0x3f;
						
						//Note: I ignore any register-reuse flags here.
					} else {
						cerr << "SANITY CHECK ERROR py~335.\n";
						cerr << "\tUnsupported architecture.\n";
					}
					
					_lastSCHIVal++;
				}
				addLast(&_currentBlock->instructions, i);
				_lastInstruction = i;
				i->label = _lastLabel;
				_lastLabel = 0;
				_addr += i->size;
				_currentBlock->size += i->size;
				
				//Increase _num_registers if appropriate:
				for(int x = 0; x < i->num_operands; x++) {
					int reg = i->operands[x]->reg;
					if(i->operands[x]->width == 2) {
						reg -= reg % 2;
						reg += 1;
					} else if(i->operands[x]->width == 4) {
						reg -= reg % 4;
						reg += 3;
					} else if(i->operands[x]->width == 3) {
						reg -= reg % 4;
						reg += 2;
					}
					
					if(reg >= _num_registers) {
						_num_registers = reg + 1;
					}
				}
				
				if(hasMod(i, "S") || i->op == opcode_SYNC) {
					if(_currentBlock->end == end_generic) {
						_just_branched = true;
						_currentBlock->end = end_branch;
					}
					else {
						cerr << "SANITY CHECK FAILED ~243: '.S' on a nongeneric instruction, line " << _counter << ".\n";
						cerr << "\tThis means an instruction has contradictory control flow implications, such as\n";
						cerr << "\t re-converging to one location while branching to another.\n";
					}
				}
			}
		|	{
				//Check previous instruction's predicate guard to decide basic block layout:
				if(_last_guard != 'z') {//previous instruction had a predicate guard
					_last_guard = 'z';
					
					//If the current block is nonempty, close it up and create a new one:
					if(_currentBlock->first != _counter) {
						_currentBlock->last = _counter - 1;
						blockNode * newBlock;
						initBlock(&newBlock);
						newBlock->first = _counter;
						newBlock->address = _addr;
						newBlock->id = _currentBlock->id + 1;
						if(_currentBlock->guarded || _currentBlock->end == end_generic) {//new block is successor of old block
							addNode(&_currentBlock->forward, (void*)newBlock, &blockorder);
							addNode(&newBlock->predecessors, (void*)_currentBlock, &blockorder);
						}
						if(_lastBlock) {
							addLast(&_lastBlock, (void*)_currentBlock);
							_lastBlock = _lastBlock->next;
						}
						else {
							addLast(&_blocks, (void*)_currentBlock);
							_lastBlock = _blocks;
						}
						_currentBlock = newBlock;
					}
				}
			}
			instruction
			{
				//Add instruction to basic block:
				instruction * i = (instruction*) $2.value;
				i->original_line = _counter;
				i->address = _addr;
				i->line = _counter;
				if(_lastSCHI && _lastSCHIVal < _lastSCHI->num_operands) {
					int schival = _lastSCHI->operands[(int)_lastSCHIVal]->val1;
					if(_arch >= 30 && _arch < 50) {
						i->SCHIVal = schival;
					} else if(_arch >= 50 && _arch < 70) {
						i->SCHIVal = schival & 0x1f;
						schival = schival >> 5;
						i->depBarrierW = schival & 0x7;
						schival = schival >> 3;
						i->depBarrierR = schival & 0x7;
						schival = schival >> 3;
						i->depBarrierMask = schival & 0x3f;
						
						//Note: I ignore any register-reuse flags here.
					} else {
						cerr << "SANITY CHECK ERROR py~336.\n";
						cerr << "\tUnsupported architecture.\n";
					}
					_lastSCHIVal++;
				}
				addLast(&_currentBlock->instructions, i);
				_lastInstruction = i;
				i->label = _lastLabel;
				_lastLabel = 0;
				_addr += i->size;
				_currentBlock->size += i->size;
				
				//Increase _num_registers if appropriate:
				for(int x = 0; x < i->num_operands; x++) {
					int reg = i->operands[x]->reg;
					if(i->operands[x]->width == 2) {
						reg -= reg % 2;
						reg += 1;
					} else if(i->operands[x]->width == 4) {
						reg -= reg % 4;
						reg += 3;
					} else if(i->operands[x]->width == 3) {
						reg -= reg % 4;
						reg += 2;
					}
					
					if(reg >= _num_registers) {
						_num_registers = reg + 1;
					}
				}
				
				if(hasMod(i, "S") || i->op == opcode_SYNC) {
					if(_currentBlock->end == end_generic) {
						_just_branched = true;
						_currentBlock->end = end_branch;
					}
					else {
						cerr << "SANITY CHECK FAILED ~301: '.S' on a nongeneric instruction, line " << _counter << ".\n";
						cerr << "\tThis means an instruction has contradictory control flow implications, such as\n";
						cerr << "\t re-converging to one location while branching to another.\n";
					}
				}
			}
		|	SCHI operands
			{
				//Add instruction to basic block:
				instruction * i = newInstruction(opcode_SCHI, 0, $2.next);
				i->original_line = _counter;
				i->line = _counter;
				i->address = _addr;
				addLast(&_currentBlock->instructions, i);
				_lastInstruction = i;
				i->label = _lastLabel;
				_lastLabel = 0;
				_addr += i->size;
				_currentBlock->size += i->size;
				_lastSCHI = i;
				_lastSCHIVal = 0;
			}
;

predicate_guard	:	GUARD operand
			{
				//Make sure operand is a predicate:
				if(((operand*)$2.value)->type != type_predicate) {
					cerr << "SANITY CHECK FAILED: guarded non-predicate.\n";
					cerr << "\tThis means the assembly has a nonsensical predicate guard, such as @[R1+0x4]\n";
				}
				
				$$ = $2;
			}
;

mods	:	MOD mods
		{
			//Store MOD's text for use by the associated instruction
			node * first = (node*) malloc(sizeof(node));
			first->value = $1.lexeme;
			first->next = $2.next;
			$$.next = first;
		}
	|	/* empty */ {$$.next = 0;}
;

operand	:	REG
		{
			//Setup for register operand:
			unsigned long long val1 = -1;
			operand_prop props = (operand_prop) 0;
			
			//Loop to find the register's value, and any unary operations:
			int len = strlen($1.lexeme);
			int x;
			for(x = 0; x < len; x++) {
				if($1.lexeme[x] == '|') {
					props = props | prop_absolute_value;
				}
				else if($1.lexeme[x] == '-') {
					props = props | prop_minus;
				}
				else if($1.lexeme[x] == '~') {
					props = props | prop_bitwise_complement;
				}
				else if($1.lexeme[x] == '!') {
					props = props | prop_not;
				}
				
				else if($1.lexeme[x] == 'R') {
					if($1.lexeme[x+1] == 'Z') {//zero register RZ
						val1 = -1;
						x++;
					}
					else {
						val1 = atoi($1.lexeme+x+1);
						x++;
						if(val1 > 9) {
							x++;
						}
						if(val1 > 99) {
							x++;
						}
						if(val1 > 999) {
							x++;
						}
					}
				}
				else {//TODO add similar warnings elsewhere
					cerr << "WARNING: unrecognized character '" << $1.lexeme[x] << "' in register operand.\n";
					cerr << "\t(This warning may suggest that the instruction format has changed.)\n";
				}
			}
			
			$$.value = newOperand(type_register, props, val1, 0, 0);
		}
	|	MEMORY
		{
			//Setup for memory-address operand
			unsigned long long val1 = -1;
			int val2 = 0;
			operand_prop props = (operand_prop) 0;
			
			//Loop to find values of the operand's components, and any unary operations:
			int len = strlen($1.lexeme) - 1;
			int x;
			char seenBracket = 0;
			char negateOffset = 0;//set to true iff the constant offset is a negative number
			for(x = 0; x < len; x++) {
				if($1.lexeme[x] == '|') {
					props = props | prop_absolute_value;
				}
				else if($1.lexeme[x] == '-') {
					if(seenBracket) {
						negateOffset = 1;
					}
					else {
						props = props | prop_minus;
					}
				}
				else if($1.lexeme[x] == '~') {
					props = props | prop_bitwise_complement;
				}
				else if($1.lexeme[x] == '!') {
					props = props | prop_not;
				}
				
				else if($1.lexeme[x] == '[') {
					seenBracket = 1;
				}
				else if($1.lexeme[x] == 'R') {
					if($1.lexeme[x+1] == 'Z') {//zero register RZ
						val1 = -1;
					}
					else {
						val1 = atoi($1.lexeme+x+1);
					}
					x += 2;
				}
				else if($1.lexeme[x] == 'x') {
					val2 = strtoul($1.lexeme + x + 1, NULL, 16);
					if(negateOffset) {//the offset is negative
						val2 = -val2;
					}
				}
			}
			
			$$.value = newOperand(type_mem, props, val1, val2, 0);
		}
	|	CONST
		{
			//Setup for constant-memory-address operand
			unsigned long long val1 = -1;
			int val2 = 0;
			int val3 = 0;
			operand_prop props = (operand_prop) 0;
			
			//Loop to find values of the operand's components, and any unary operations:
			int len = strlen($1.lexeme) - 1;
			char second = 0;
			int x;
			char negateOffset = 0;//set to true iff the constant offset is a negative number
			char seenBracket = 0;
			for(x = 0; x < len; x++) {
				if($1.lexeme[x] == '|') {
					props = props | prop_absolute_value;
				}
				else if($1.lexeme[x] == '-') {
					if(seenBracket) {//TODO double check that this makes sense
						if(second) {
							negateOffset = 1;
						} else {
							cerr << "SANITY CHECK FAILED ~341: negative memory bank\n";
							cerr << "\tA constant memory operand appears to have a nonsensical bank number.\n";
						}
					}
					else {
						props = props | prop_minus;
					}
				}
				else if($1.lexeme[x] == '~') {
					props = props | prop_bitwise_complement;
				}
				else if($1.lexeme[x] == '!') {
					props = props | prop_not;
				}
				
				else if($1.lexeme[x] == '[') {
					seenBracket = 1;
				}
				else if($1.lexeme[x] == 'R') {
					if($1.lexeme[x+1] == 'Z') {//zero register RZ
						val1 = -1;
					}
					else {
						val1 = atoi($1.lexeme + x + 1);
					}
					x += 2;
				}
				else if($1.lexeme[x] == 'x') {
					if(second) {
						val3 = strtoul($1.lexeme + x + 1, NULL, 16);
						if(negateOffset) {
							val3 = -val3;
						}
					}
					else {
						val2 = strtoul($1.lexeme + x + 1, NULL, 16);
					}
				}
				else if($1.lexeme[x] == ']') {
					second = 1;
				}
			}
			
			$$.value = newOperand(type_const_mem, props, val1, val2, val3);
		}
	|	SPECIALNAME
		{
			//Special-register operand (by name)
			$$.value = newOperand(type_special_reg, getSpecialID($1.lexeme+3, true, _arch));
		}
	|	SPECIALID
		{
			//Special-register operand (by id)
			$$.value = newOperand(type_special_reg, atoi($1.lexeme+2));
		}
	|	PREDICATE
		{
			//Setup for predicate operand
			unsigned long long val1 = 7;
			operand_prop props = (operand_prop) 0;
			
			//Loop to find predicate's value, and any unary operations:
			int len = strlen($1.lexeme);
			int x;
			for(x = 0; x < len; x++) {
				if($1.lexeme[x] == '|') {
					props = props | prop_absolute_value;
				}
				else if($1.lexeme[x] == '-') {
					props = props | prop_minus;
				}
				else if($1.lexeme[x] == '~') {
					props = props | prop_bitwise_complement;
				}
				else if($1.lexeme[x] == '!') {
					props = props | prop_not;
				}
				
				else if($1.lexeme[x] == 'P') {
					if($1.lexeme[x+1] == 't' || $1.lexeme[x+1] == 'T') {//null predicate pt
						val1 = 7;
					}
					else {
						val1 = atoi($1.lexeme+x+1);
					}
				}
				else if($1.lexeme[x] == 'p' && $1.lexeme[x+1] == 't') {//null predicate pt
					val1 = 7;
				}
			}
			
			$$.value = newOperand(type_predicate, props, val1, 0, 0);
		}
	|	HEXVAL
		{
			//Setup for hex operand
			unsigned long long val1 = -1;
			operand_prop props = (operand_prop) 0;
			
			//Loop to find hex value, and any unary operations:
			int len = strlen($1.lexeme);
			for(int x = 0; x < len; x++) {
				if($1.lexeme[x] == '|') {
					props = props | prop_absolute_value;
				}
				else if($1.lexeme[x] == '-') {
					props = props | prop_minus;
				}
				else if($1.lexeme[x] == '~') {
					props = props | prop_bitwise_complement;
				}
				else if($1.lexeme[x] == '!') {
					props = props | prop_not;
				}
				
				else if($1.lexeme[x] == 'x') {
					val1 = strtoul($1.lexeme + x + 1, NULL, 16);
				}
			}
			
			$$.value = newOperand(type_hex, props, val1, 0, 0);
		}
	|	BITLIST
		{
			//Setup for bit_list operand
			long long val1 = 0;
			
			//Loop to find bit IDs:
			int len = strlen($1.lexeme);
			for(int x = 0; x < len; x++) {
				if($1.lexeme[x] >= '0' && $1.lexeme[x] <= '9') {
					int bit = atoi($1.lexeme + x);
					val1 |= (0x1 << bit);
					
					while($1.lexeme[x] >= '0' && $1.lexeme[x] <= '9') {
						x++;
					}
					x--;
				} else {
				
				}
			}
			
			operand * op = newOperand(type_bit_list, (operand_prop) 0, val1, 0, 0);;
			$$.value = op;
		}
	|	DECIMAL//base-10 integer and floats shows up instead of pure hex values starting in CUDA SDK 5.5
		{
			//Setup for hex operand
			unsigned long long val1;
			float fval;
			double dval;
			operand_prop props = (operand_prop) 0;
			
			if(currentDouble) {
				dval = atof($1.lexeme);
				char * temp = (char*) &dval;
				unsigned long long * temp2 = (unsigned long long *)temp;
				val1 = *temp2;
			}
			else {
				fval = atof($1.lexeme);
				char * temp = (char*) &fval;
				unsigned int * temp2 = (unsigned int *)temp;
				val1 = *temp2;
			}
			
			if(!current32I) {
				if(!currentDouble && _arch == 35 && (val1 & 0xfff)) {//I'm not sure why this is necessary
					val1 = val1 >> 11;
					val1 &= 0x7ff;
				} else {
					val1 = val1 >> 12;
				}
			}
			if(currentDouble) {
				val1 = val1 >> 32;
			}
			operand * op = newOperand(type_hex, props, val1, 0, 0);
			
			for(unsigned int x = 0; x < strlen($1.lexeme); x++) {
				if($1.lexeme[x] == '-') {
					op->properties = op->properties | prop_minus;
				} else if($1.lexeme[x] == 'e' || $1.lexeme[x] == 'E') {
					break;
				}
			}
			
			int len = strlen($1.lexeme);
			for(int x = 0; x < len; x++) {
				if($1.lexeme[x] == 'e') {
					op->properties = op->properties | prop_exp;
					break;
				}
			}
			
			int precision = -1;
			for(int x = 0; x < len; x++) {
				if($1.lexeme[x] == '.') {
					precision = 0;
				}
				else if(precision >= 0 && $1.lexeme[x] >= '0' && $1.lexeme[x] <= '9') {
					precision++;
				}
				else if(precision >= 0) {
					break;
				}
			}
			if(precision < 0) {
				op->precision = 0;
			}
			else {
				op->precision = precision;
			}
			
			if(currentDouble) {
				op->properties = op->properties | prop_double;
			}
			else {
				op->properties = op->properties | prop_float;
			}
			if(current32I) {
				op->properties = op->properties | prop_float32i;
			}			
			$$.value = op;
		}
	|	PLUSINF
		{
			unsigned long long val1	= 0x7f80000000000000LL;
			if(currentDouble) {
				val1 = 0x7ff0000000000000LL;
			}
			val1 = val1 >> 32;
			if(!current32I) {
				val1 = val1 >> 12;
			}
			operand * op = newOperand(type_hex, (operand_prop)0, val1, 0, 0);
			if(currentDouble) {
				op->properties = op->properties | prop_double;
			}
			else {
				op->properties = op->properties | prop_float;
			}
			$$.value = op;
		}
	|	NEGINF
		{
			unsigned long long val1 = 0xff80000000000000LL;
			if(currentDouble) {
				val1 = 0xfff0000000000000LL;
			}
			val1 = val1 >> 32;
			if(!current32I) {
				val1 = val1 >> 12;
			}
			operand * op = newOperand(type_hex, (operand_prop)0, val1, 0, 0);
			if(currentDouble) {
				op->properties = op->properties | prop_double;
			}
			else {
				op->properties = op->properties | prop_float;
			}
			op->properties = op->properties | prop_minus;
			$$.value = op;
		}
	|	PLUSSNAN
		{
			unsigned long long val1 = 0x7f80020000000000LL;//TODO: verify correctness
			if(currentDouble) {
				val1 = 0x7ff0020000000000LL;//TODO: verify correctness
			}
			val1 = val1 >> 32;
			if(!current32I) {
				val1 = val1 >> 12;
			}
			operand * op = newOperand(type_hex, (operand_prop)0, val1, 0, 0);
			$$.value = op;
		}
	|	PLUSQNAN
		{
			unsigned long long val1 = 0x7fc0000000000000LL;//TODO: verify correctness
			if(currentDouble) {
				val1 = 0x7ff8000000000000LL;//TODO: verify correctness
			}
			val1 = val1 >> 32;
			if(!current32I) {
				val1 = val1 >> 12;
			}
			operand * op = newOperand(type_hex, (operand_prop)0, val1, 0, 0);
			$$.value = op;
		}
	|	LINENUMBER //Used by this tool to refer to line numbers, sometimes
		{
			//Decimal integer operand
			$$.value = newOperand(type_hex, 8*atoi($1.lexeme));
		}
	|	CC
		{
			//Weird operand used in a few operations, such as NOP, to attach modifier flags
			$$.value = newOperand(type_other_operand, getOtherID("CC"));
		}
	|	PR
		{
			//Weird operand (some sort of special predicate? used in P2R and R2P)
			$$.value = newOperand(type_other_operand, getOtherID("PR"));
		}
	|	SB_OPERAND
		{
			//Weird barrier operand (used in DEPBAR on sm_50)
			$$.value = newOperand(type_sb, atoi($1.lexeme));
		}
	|	CHANNEL
		{
			//Color channel operand, e.g. R, RGBA, A, or etcetera (used in TLDS, TEXS in sm_50)
			$$.value = newOperand(type_channel, getChannelID($1.lexeme));
		}
	|	TEXOP
		{
			//Texture operand
			$$.value = newOperand(type_texture_operand, getTextureID($1.lexeme));
		}
	|	LABEL_OP
		{
			operand * op = newOperand(type_label, -1, 0, 0);
			op->strval = $1.lexeme;
			$$.value = op;
		}
;

operands	:	operand mods operands
			{
				//Setup operand:
				operand * o = (operand*) $1.value;
				o->mods = $2.next;
				
				//If appropriate, mark operand as possible dest for instruction:
				if((o->type == type_register && o->reg != -1) || o->type == type_mem || o->type == type_predicate) {
					o->dest = true;
				} else {
					o->dest = false;
				}
				
				//Add operand to list of operands for instruction:
				node * first = (node*) malloc(sizeof(node));
				first->value = o;
				first->next = $3.next;
				if(first->next) {
					((operand*)first->next->value)->dest = false;
				}
				
				//Put operand list into $$.next for the instruction to find
				$$.next = first;
			}
		|	/*empty*/ {$$.next = 0;}
;

instruction:	MOV mods operands
		{
			instruction * inst = newInstruction(opcode_MOV ,$2.next, $3.next);
			$$.value = inst;
		}
	|	MOV32I mods {current32I = true;} operands
		{
			instruction * inst = newInstruction(opcode_MOV32I, $2.next, $4.next);
			$$.value = inst;
		}
	|	LD mods operands
		{
			instruction * inst = newInstruction(opcode_LD, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[0]->width = 2;
			}
			else if(hasMod(inst, "128")) {
				inst->operands[0]->width = 4;
			}
		}
	|	LDU mods operands
		{
			instruction * inst = newInstruction(opcode_LDU, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[0]->width = 2;
			}
			else if(hasMod(inst, "128")) {
				inst->operands[0]->width = 4;
			}
		}
	|	LDL mods operands
		{
			instruction * inst = newInstruction(opcode_LDL, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[0]->width = 2;
			}
			else if(hasMod(inst, "128")) {
				inst->operands[0]->width = 4;
			}
		}
	|	LDS mods operands
		{
			instruction * inst = newInstruction(opcode_LDS, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[0]->width = 2;
			}
			else if(hasMod(inst, "128")) {
				inst->operands[0]->width = 4;
			}
		}
	|	LDC mods operands
		{
			instruction * inst = newInstruction(opcode_LDC, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[0]->width = 2;
			}
			else if(hasMod(inst, "128")) {
				inst->operands[0]->width = 4;
			}
		}
	|	ST mods operands
		{
			instruction * inst = newInstruction(opcode_ST, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[0]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "128")) {
				inst->operands[1]->width = 4;
			}
		}
	|	STL mods operands
		{
			instruction * inst = newInstruction(opcode_STL, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[0]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "128")) {
				inst->operands[1]->width = 4;
			}
		}
	|	STS mods operands
		{
			instruction * inst = newInstruction(opcode_STS, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[0]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "128")) {
				inst->operands[1]->width = 4;
			}
		}
	|	LDLK mods operands
		{
			instruction * inst = newInstruction(opcode_LDLK, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[0]->width = 2;
			}
			else if(hasMod(inst, "128")) {
				inst->operands[0]->width = 4;
			}
		}
	|	LDSLK mods operands
		{
			instruction * inst = newInstruction(opcode_LDSLK, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[0]->width = 2;
			}
			else if(hasMod(inst, "128")) {
				inst->operands[0]->width = 4;
			}
		}
	|	STUL mods operands
		{
			instruction * inst = newInstruction(opcode_STUL, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[0]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "128")) {
				inst->operands[1]->width = 4;
			}
		}
	|	STSUL mods operands
		{
			instruction * inst = newInstruction(opcode_STSUL, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[0]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "128")) {
				inst->operands[1]->width = 4;
			}
		}
	|	FADD mods operands
		{
			instruction * inst = newInstruction(opcode_FADD, $2.next, $3.next);
			$$.value = inst;
		}
	|	FADD32I mods {current32I = true;} operands
		{
			instruction * inst = newInstruction(opcode_FADD32I, $2.next, $4.next);
			$$.value = inst;
		}
	|	FMUL mods operands
		{
			instruction * inst = newInstruction(opcode_FMUL, $2.next, $3.next);
			$$.value = inst;
		}
	|	FMUL32I mods {current32I = true;} operands
		{
			instruction * inst = newInstruction(opcode_FMUL32I, $2.next, $4.next);
			$$.value = inst;
		}
	|	FFMA mods operands
		{
			instruction * inst = newInstruction(opcode_FFMA, $2.next, $3.next);
			$$.value = inst;
		}
	|	FSET mods operands
		{
			instruction * inst = newInstruction(opcode_FSET, $2.next, $3.next);
			$$.value = inst;
		}
	|	FSETP mods operands
		{
			instruction* inst = newInstruction(opcode_FSETP, $2.next, $3.next);
			$$.value = inst;
			
			inst->operands[0]->dest = true;
			inst->operands[1]->dest = true;
			
			//Check if current predicate guard has been altered, as it may affect block structure:
			if(_last_guard == (long long) inst->operands[0]->val1) {
				_last_guard = 'z';
			}
			else if(_last_guard == (long long) inst->operands[1]->val1) {
				_last_guard = 'z';
			}
		}
	|	DSETP mods {currentDouble = true;} operands
		{
			instruction* inst = newInstruction(opcode_DSETP, $2.next, $4.next);
			$$.value = inst;
			
			inst->operands[0]->dest = true;
			inst->operands[1]->dest = true;
			
			for(int x = 0; x < inst->num_operands; x++) {
				if(inst->operands[x]->reg >= 0) {
					inst->operands[x]->width = 2;
				}
			}
			
			//Check if current predicate guard has been altered, as it may affect block structure:
			if(_last_guard == (long long) inst->operands[0]->val1) {
				_last_guard = 'z';
			}
			else if(_last_guard == (long long) inst->operands[1]->val1) {
				_last_guard = 'z';
			}
		}
	|	FCMP mods operands
		{
			instruction * inst = newInstruction(opcode_FCMP, $2.next, $3.next);
			$$.value = inst;
		}
	|	MUFU mods operands
		{
			instruction * inst = newInstruction(opcode_MUFU, $2.next, $3.next);
			$$.value = inst;
		}
	|	DADD mods {currentDouble = true;} operands
		{
			instruction * inst = newInstruction(opcode_DADD, $2.next, $4.next);
			$$.value = inst;
			
			for(int x = 0; x < inst->num_operands; x++) {
				if(inst->operands[x]->reg >= 0) {
					inst->operands[x]->width = 2;
				}
			}
		}
	|	DMUL mods {currentDouble = true;} operands
		{
			instruction * inst = newInstruction(opcode_DMUL, $2.next, $4.next);
			$$.value = inst;
			
			for(int x = 0; x < inst->num_operands; x++) {
				if(inst->operands[x]->reg >= 0) {
					inst->operands[x]->width = 2;
				}
			}
		}
	|	DFMA mods {currentDouble = true;} operands
		{
			instruction * inst = newInstruction(opcode_DFMA, $2.next, $4.next);
			$$.value = inst;
			
			for(int x = 0; x < inst->num_operands; x++) {
				if(inst->operands[x]->reg >= 0) {
					inst->operands[x]->width = 2;
				}
			}
		}
	|	IADD mods operands
		{
			instruction * inst = newInstruction(opcode_IADD, $2.next, $3.next);
			$$.value = inst;
		}
	|	ISUB mods operands
		{
			instruction * inst = newInstruction(opcode_ISUB, $2.next, $3.next);
			$$.value = inst;
		}
	|	IADD32I mods {current32I = true;} operands
		{
			instruction * inst = newInstruction(opcode_IADD32I, $2.next, $4.next);
			$$.value = inst;
		}
	|	IMNMX mods operands
		{
			instruction * inst = newInstruction(opcode_IMNMX, $2.next, $3.next);
			$$.value = inst;
		}
	|	IMUL mods operands
		{
			instruction * inst = newInstruction(opcode_IMUL, $2.next, $3.next);
			$$.value = inst;
		}
	|	IMUL32I mods {current32I = true;} operands
		{
			instruction * inst = newInstruction(opcode_IMUL32I, $2.next, $4.next);
			$$.value = inst;
		}
	|	IMAD mods operands
		{
			instruction * inst = newInstruction(opcode_IMAD, $2.next, $3.next);
			$$.value = inst;
		}
	|	ISCADD mods operands
		{
			instruction * inst = newInstruction(opcode_ISCADD, $2.next, $3.next);
			$$.value = inst;
		}
	|	ISET mods operands
		{
			instruction * inst = newInstruction(opcode_ISET, $2.next, $3.next);
			$$.value = inst;
		}
	|	ISETP mods operands
		{
			instruction* inst = newInstruction(opcode_ISETP, $2.next, $3.next);
			$$.value = inst;
			
			inst->operands[0]->dest = true;
			inst->operands[1]->dest = true;
			
			//Check if current predicate guard has been altered, as it may affect block structure:
			if(_last_guard == (long long) inst->operands[0]->val1) {
				_last_guard = 'z';
			}
			else if(_last_guard == (long long) inst->operands[1]->val1) {
				_last_guard = 'z';
			}
		}
	|	ICMP mods operands
		{
			instruction * inst = newInstruction(opcode_ICMP, $2.next, $3.next);
			$$.value = inst;
		}
	|	I2F mods operands
		{
			instruction * inst = newInstruction(opcode_I2F, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "S64")) {
				inst->operands[1]->width = 2;
			}
			else if(hasMod(inst, "U64")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "F64")) {
				inst->operands[0]->width = 2;
			}
			
			inst->operands[1]->converted = true;
		}
	|	I2I mods operands
		{
			instruction * inst = newInstruction(opcode_I2I, $2.next, $3.next);
			$$.value = inst;
			
			if(hasTypeMod(inst, "S64", 0)) {
				inst->operands[0]->width = 2;
			}
			else if(hasTypeMod(inst, "U64", 0)) {
				inst->operands[0]->width = 2;
			}
			if(hasTypeMod(inst, "S64", 1)) {
				inst->operands[1]->width = 2;
			}
			else if(hasTypeMod(inst, "U64", 1)) {
				inst->operands[1]->width = 2;
			}
			
			inst->operands[1]->converted = true;
		}
	|	F2I mods operands
		{
			instruction * inst = newInstruction(opcode_F2I, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "S64")) {
				inst->operands[0]->width = 2;
			}
			else if(hasMod(inst, "U64")) {
				inst->operands[0]->width = 2;
			}
			if(hasMod(inst, "F64")) {
				inst->operands[1]->width = 2;
			}
			
			inst->operands[1]->converted = true;
		}
	|	F2F mods operands
		{
			instruction * inst = newInstruction(opcode_F2F, $2.next, $3.next);
			$$.value = inst;
			
			if(hasTypeMod(inst, "F64", 0)) {
				inst->operands[0]->width = 2;
			}
			if(hasTypeMod(inst, "F64", 1)) {
				inst->operands[1]->width = 2;
			}
			
			inst->operands[1]->converted = true;
		}
	|	LOP mods operands
		{
			instruction * inst = newInstruction(opcode_LOP, $2.next, $3.next);
			$$.value = inst;
		}
	|	LOP32I mods {current32I = true;} operands
		{
			instruction * inst = newInstruction(opcode_LOP32I, $2.next, $4.next);
			$$.value = inst;
		}
	|	SHL mods operands
		{
			instruction * inst = newInstruction(opcode_SHL, $2.next, $3.next);
			$$.value = inst;
		}
	|	SHR mods operands
		{
			instruction * inst = newInstruction(opcode_SHR, $2.next, $3.next);
			$$.value = inst;
		}
	|	BFE mods operands
		{
			instruction * inst = newInstruction(opcode_BFE, $2.next, $3.next);
			$$.value = inst;
		}
	|	BFI mods operands
		{
			instruction * inst = newInstruction(opcode_BFI, $2.next, $3.next);
			$$.value = inst;
		}
	|	SEL mods operands
		{
			instruction * inst = newInstruction(opcode_SEL, $2.next, $3.next);
			$$.value = inst;
		}
	|	SSY mods operands
		{
			instruction * inst = newInstruction(opcode_SSY, $2.next, $3.next);
			inst->operands[0]->dest = 0;//SSY does not write to a register
			$$.value = inst;
		}
	|	BRA mods operands
		{
			instruction * inst = newInstruction(opcode_BRA, $2.next, $3.next);
			$$.value = inst;
			
			int lastOperand = inst->num_operands - 1;
			
			//Fix block settings to compensate for branch:
			_just_branched = true;
			if(inst->operands[lastOperand]->type == type_hex) {
				_currentBlock->target = inst->operands[lastOperand]->val1;
			}
			else {
				_currentBlock->target = -1;
			}
			_currentBlock->end = end_branch;
			
			//Sanity check:
			if(inst->operands[lastOperand]->type != type_hex && inst->operands[lastOperand]->type != type_label) {
				printf("\nSANITY CHECK FAILED py~251: expected hexval or label at (%d)\n", _counter);
			}
		}
	|	BRX mods operands
		{
			instruction * inst = newInstruction(opcode_BRX, $2.next, $3.next);
			$$.value = inst;
			inst->operands[0]->dest = 0;
			
			_just_branched = true;
			
			//TODO handle BRX
			fprintf(stderr,"WARNING: BRX address calculation not implemented.\n");
		}
	|	PCNT mods operands
		{
			instruction * inst = newInstruction(opcode_PCNT, $2.next, $3.next);
			$$.value = inst;
			
			//Sanity check:
			if((inst->operands[0]->type != type_hex && inst->operands[0]->type != type_label) || inst->num_operands > 1) {
				printf("\nSANITY CHECK FAILED py~262: expected hexval or label at (%d)\n", _counter);
			}
		}
	|	CONT operands
		{
			instruction * inst = newInstruction(opcode_CONT, 0, $2.next);
			$$.value = inst;
			
			//Fix block settings to compensate for branch:
			_just_branched = true;
			_currentBlock->end = end_branch;
		}
	|	PBK mods operands
		{
			instruction * inst = newInstruction(opcode_PBK, $2.next, $3.next);
			$$.value = inst;
			
			//Sanity check:
			if((inst->operands[0]->type != type_hex && inst->operands[0]->type != type_label) || inst->num_operands > 1) {
				printf("\nSANITY CHECK FAILED py~279: expected hexval or label at (%d)\n", _counter);
			}
		}
	|	BRK operands
		{
			instruction * inst = newInstruction(opcode_BRK, 0, $2.next);
			$$.value = inst;
			
			//Fix block settings to compensate for branch:
			_just_branched = true;
			_currentBlock->end = end_branch;
		}
	|	CAL mods operands
		{
			instruction * inst = newInstruction(opcode_CAL, $2.next, $3.next);
			$$.value = inst;
			
			//Fix block settings to compensate for branch:
			_just_branched = true;
			if(inst->operands[0]->type == type_hex) {
				_currentBlock->target = inst->operands[0]->val1;
			}
			else {
				_currentBlock->target = -1;
			}
			_currentBlock->end = end_call;
			
			//Sanity check:
			if((inst->operands[0]->type != type_hex && inst->operands[0]->type != type_label) || inst->num_operands > 1) {
				printf("\nSANITY CHECK FAILED py~298: expected hexval or label at (%d)\n", _counter);
			}
		}
	|	RET operands
		{
			instruction * inst = newInstruction(opcode_RET, 0, $2.next);
			$$.value = inst;
			
			//Fix block settings to compensate for branch:
			_just_branched = true;
			_currentBlock->end = end_return;
		}
	|	EXIT mods operands
		{
			instruction * inst = newInstruction(opcode_EXIT, $2.next, $3.next);
			$$.value = inst;
			
			//Fix block settings to compensate for exit:
			_just_branched = true;
			_currentBlock->end = end_exit;
		}
	|	NOP mods operands
		{
			instruction * inst = newInstruction(opcode_NOP, $2.next, $3.next);
			$$.value = inst;
		}
	|	BAR mods operands
		{
			instruction * inst = newInstruction(opcode_BAR, $2.next, $3.next);
			if(inst->num_operands) {
				inst->operands[0]->dest = 0;//BAR does not write to a register
			}
			$$.value = inst;
		}
	|	BPT mods operands
		{
			instruction * inst = newInstruction(opcode_BPT, $2.next, $3.next);
			$$.value = inst;
		}
	|	B2R mods operands
		{
			instruction * inst = newInstruction(opcode_B2R, $2.next, $3.next);
			$$.value = inst;
		}
	|	S2R mods operands
		{
			instruction * inst = newInstruction(opcode_S2R, $2.next, $3.next);
			$$.value = inst;
		}
	|	PSETP mods operands
		{
			instruction* inst = newInstruction(opcode_PSETP, $2.next, $3.next);
			$$.value = inst;
			
			inst->operands[0]->dest = true;
			inst->operands[1]->dest = true;
			
			//Check if current predicate guard has been altered, as it may affect block structure:
			if(_last_guard == (long long) inst->operands[0]->val1) {
				_last_guard = 'z';
			}
			else if(_last_guard == (long long) inst->operands[1]->val1) {
				_last_guard = 'z';
			}
		}
	|	PSET mods operands
		{
			instruction * inst = newInstruction(opcode_PSET, $2.next, $3.next);
			$$.value = inst;
		}
	|	FLO mods operands
		{
			instruction * inst = newInstruction(opcode_FLO, $2.next, $3.next);
			$$.value = inst;
		}
	|	P2R mods operands
		{
			instruction * inst = newInstruction(opcode_P2R, $2.next, $3.next);
			$$.value = inst;
		}
	|	R2P mods operands
		{
			instruction * inst = newInstruction(opcode_R2P, $2.next, $3.next);
			$$.value = inst;
		}
	|	TEX mods operands
		{
			instruction * inst = newInstruction(opcode_TEX, $2.next, $3.next);
			
			int op;
			for(op = 0; op < inst->num_operands; op++) {
				if(inst->operands[op]->type == type_texture_operand) {
					break;
				}
			}
			
			int argwidth;
			if(inst->operands[op]->val1 == getTextureID("1D")) {
				argwidth = 1;
			} else if(inst->operands[op]->val1 == getTextureID("2D")) {
				argwidth = 2;
			} else if(inst->operands[op]->val1 == getTextureID("ARRAY_1D")) {
				argwidth = 2;
			} else if(inst->operands[op]->val1 == getTextureID("RECT")) {
				argwidth = 2;
			} else if(inst->operands[op]->val1 == getTextureID("ARRAY_2D")) {
				argwidth = 3;
			} else if(inst->operands[op]->val1 == getTextureID("3D")) {
				argwidth = 3;
			} else if(inst->operands[op]->val1 == getTextureID("CUBE")) {
				argwidth = 3;
			} else if(inst->operands[op]->val1 == getTextureID("ARRAY_CUBE")) {
				argwidth = 4;
			} else {
				cerr << "FATAL ERROR: Unrecognized texture shape operand.\n";
				exit(0);
			}

			for(int x = 1; x < inst->num_operands; x++) {
				if(inst->operands[x]->type == type_register && inst->operands[x]->reg >= 0) {
					inst->operands[x]->width = argwidth;
				}
			}
			
			inst->operands[0]->width = 0;
			for(int x = 0; x < 4; x++) {
				if(inst->operands[inst->num_operands - 1]->val1 & (0x1 << x)) {
					inst->operands[0]->width++;
				}
			}
			
			$$.value = inst;
		}
	|	TEXDEPBAR mods operands
		{
			instruction * inst = newInstruction(opcode_TEXDEPBAR, $2.next, $3.next);
			$$.value = inst;
		}
	|	RRO mods operands
		{
			instruction * inst = newInstruction(opcode_RRO, $2.next, $3.next);
			$$.value = inst;
		}
	|	PRMT mods operands
		{
			instruction * inst = newInstruction(opcode_PRMT, $2.next, $3.next);
			$$.value = inst;
		}
	|	VADD mods operands
		{
			instruction * inst = newInstruction(opcode_VADD, $2.next, $3.next);
			$$.value = inst;
		}
	|	DMNMX mods {currentDouble = true;} operands
		{
			instruction * inst = newInstruction(opcode_DMNMX, $2.next, $4.next);
			$$.value = inst;
			
			for(int x = 0; x < inst->num_operands; x++) {
				if(inst->operands[x]->reg >= 0) {
					inst->operands[x]->width = 2;
				}
			}
		}
	|	FMNMX mods operands
		{
			instruction * inst = newInstruction(opcode_FMNMX, $2.next, $3.next);
			$$.value = inst;
		}
	|	RED mods operands
		{
			instruction * inst = newInstruction(opcode_RED, $2.next, $3.next);
			$$.value = inst;
		}
	|	VOTE mods operands
		{
			instruction * inst = newInstruction(opcode_VOTE, $2.next, $3.next);
			$$.value = inst;
		}
	|	POPC mods operands
		{
			instruction * inst = newInstruction(opcode_POPC, $2.next, $3.next);
			$$.value = inst;
		}
	|	MEMBAR mods operands
		{
			instruction * inst = newInstruction(opcode_MEMBAR, $2.next, $3.next);
			$$.value = inst;
		}
	|	STSCUL mods operands
		{
			instruction * inst = newInstruction(opcode_STSCUL, $2.next, $3.next);
			$$.value = inst;
		}
	|	LEPC mods operands
		{
			instruction * inst = newInstruction(opcode_LEPC, $2.next, $3.next);
			$$.value = inst;
		}
	|	CSETP mods operands
		{
			instruction * inst = newInstruction(opcode_CSETP, $2.next, $3.next);
			$$.value = inst;
			
			//TODO double check these are really both destination operands:
			inst->operands[0]->dest = true;
			inst->operands[1]->dest = true;
		}
	|	ISCADD32I mods {current32I = true;} operands
		{
			instruction * inst = newInstruction(opcode_ISCADD32I, $2.next, $4.next);
			$$.value = inst;
		}
	|	VMNMX mods operands
		{
			instruction * inst = newInstruction(opcode_VMNMX, $2.next, $3.next);
			$$.value = inst;
		}
	|	TLD mods operands
		{
			instruction * inst = newInstruction(opcode_TLD, $2.next, $3.next);
			
			int op;
			for(op = 0; op < inst->num_operands; op++) {
				if(inst->operands[op]->type == type_texture_operand) {
					break;
				}
			}
			
			int argwidth;
			if(inst->operands[op]->val1 == getTextureID("1D")) {
				argwidth = 1;
			} else if(inst->operands[op]->val1 == getTextureID("2D")) {
				argwidth = 2;
			} else if(inst->operands[op]->val1 == getTextureID("ARRAY_1D")) {
				argwidth = 2;
			} else if(inst->operands[op]->val1 == getTextureID("RECT")) {
				argwidth = 2;
			} else if(inst->operands[op]->val1 == getTextureID("ARRAY_2D")) {
				argwidth = 3;
			} else if(inst->operands[op]->val1 == getTextureID("3D")) {
				argwidth = 3;
			} else if(inst->operands[op]->val1 == getTextureID("CUBE")) {
				argwidth = 3;
			} else if(inst->operands[op]->val1 == getTextureID("ARRAY_CUBE")) {
				argwidth = 4;
			} else {
				cerr << "FATAL ERROR: Unrecognized texture shape operand.\n";
				exit(0);
			}

			for(int x = 1; x < inst->num_operands; x++) {
				if(inst->operands[x]->type == type_register && inst->operands[x]->reg >= 0) {
					inst->operands[x]->width = argwidth;
				}
			}
			
			inst->operands[0]->width = 0;
			for(int x = 0; x < 4; x++) {
				if(inst->operands[inst->num_operands - 1]->val1 & (0x1 << x)) {
					inst->operands[0]->width++;
				}
			}
			
			$$.value = inst;
		}
	|	SHF mods operands
		{
			instruction * inst = newInstruction(opcode_SHF, $2.next, $3.next);
			$$.value = inst;
		}
	|	FCHK mods operands
		{
			instruction * inst = newInstruction(opcode_FCHK, $2.next, $3.next);
			$$.value = inst;
		}
	|	JCAL mods operands
		{
			instruction * inst = newInstruction(opcode_JCAL, $2.next, $3.next);
			$$.value = inst;
		}
	|	SHFL mods operands
		{
			instruction * inst = newInstruction(opcode_SHFL, $2.next, $3.next);
			$$.value = inst;
		}
	|	LDG mods operands
		{
			instruction * inst = newInstruction(opcode_LDG, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[1]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[0]->width = 2;
			}
			else if(hasMod(inst, "128")) {
				inst->operands[0]->width = 4;
			}
		}
	|	LD_LDU mods operands
		{
			instruction * inst = newInstruction(opcode_LD_LDU, $2.next, $3.next);
			$$.value = inst;
			
			inst->operands[0]->dest = true;
			inst->operands[1]->dest = true;
			
			if(hasMod(inst, "E")) {
				inst->operands[2]->width = 2;
				inst->operands[3]->width = 2;
			}
			if(hasTypeMod(inst, "64", 0)) {
				inst->operands[0]->width = 2;
			} else if(hasTypeMod(inst, "128", 0)) {
				inst->operands[0]->width = 4;
			}
			if(hasTypeMod(inst, "64", 1)) {
				inst->operands[1]->width = 2;
			} else if(hasTypeMod(inst, "128", 1)) {
				inst->operands[1]->width = 4;
			}
		}
	|	ATOM mods operands
		{
			instruction * inst = newInstruction(opcode_ATOM, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				for(int x = 0; x < inst->num_operands; x++) {
					if(inst->operands[x]->type == type_mem) {
						inst->operands[x]->width = 2;
					}
				}
			} else {
				//TODO handle shared memory ATOM?
			}
		}
	|	CCTL mods operands
		{
			instruction * inst = newInstruction(opcode_CCTL, $2.next, $3.next);
			$$.value = inst;
			
			//TODO figure out what this instruction is actually doing, see if the below makes sense:
			if(hasMod(inst, "E")) {
				for(int x = 0; x < inst->num_operands; x++) {
					if(inst->operands[x]->type == type_mem) {
						inst->operands[x]->width = 2;
					}
				}
			}
		}
	|	XMAD mods operands
		{
			instruction * inst = newInstruction(opcode_XMAD, $2.next, $3.next);
			$$.value = inst;
		}
	|	SYNC mods operands
		{
			instruction * inst = newInstruction(opcode_SYNC, $2.next, $3.next);
			$$.value = inst;
		}
	|	STG mods operands
		{
			instruction * inst = newInstruction(opcode_STG, $2.next, $3.next);
			$$.value = inst;
			
			if(hasMod(inst, "E")) {
				inst->operands[0]->width = 2;
			}
			if(hasMod(inst, "64")) {
				inst->operands[1]->width = 2;
			}
			else if(hasMod(inst, "128")) {
				inst->operands[1]->width = 4;
			}
		}
	|	IADD3 mods operands
		{
			instruction * inst = newInstruction(opcode_IADD3, $2.next, $3.next);
			$$.value = inst;
		}
	|	VABSDIFF mods operands
		{
			instruction * inst = newInstruction(opcode_VABSDIFF, $2.next, $3.next);
			$$.value = inst;
		}
	|	DEPBAR mods operands
		{
			instruction * inst = newInstruction(opcode_DEPBAR, $2.next, $3.next);
			$$.value = inst;
		}
	|	LOP3 mods operands
		{
			instruction * inst = newInstruction(opcode_LOP3, $2.next, $3.next);
			$$.value = inst;
		}
	|	TLDS mods operands
		{
			instruction * inst = newInstruction(opcode_TLDS, $2.next, $3.next);
			
			int op;
			for(op = 0; op < inst->num_operands; op++) {
				if(inst->operands[op]->type == type_texture_operand) {
					break;
				}
			}
			
			//TODO confirm that these widths are correct:
			int argwidth;
			if(inst->operands[op]->val1 == getTextureID("1D")) {
				argwidth = 1;
			} else if(inst->operands[op]->val1 == getTextureID("2D")) {
				argwidth = 2;
			} else if(inst->operands[op]->val1 == getTextureID("ARRAY_1D")) {
				argwidth = 2;
			} else if(inst->operands[op]->val1 == getTextureID("RECT")) {
				argwidth = 2;
			} else if(inst->operands[op]->val1 == getTextureID("ARRAY_2D")) {
				argwidth = 3;
			} else if(inst->operands[op]->val1 == getTextureID("3D")) {
				argwidth = 3;
			} else if(inst->operands[op]->val1 == getTextureID("CUBE")) {
				argwidth = 3;
			} else if(inst->operands[op]->val1 == getTextureID("ARRAY_CUBE")) {
				argwidth = 4;
			} else {
				cerr << "FATAL ERROR: Unrecognized texture shape operand.\n";
				exit(0);
			}
			
			for(int x = 1; x < inst->num_operands; x++) {
				if(inst->operands[x]->type == type_register && inst->operands[x]->reg >= 0) {
					inst->operands[x]->width = argwidth;
				}
			}
			
			$$.value = inst;
		}
	|	TEXS mods operands
		{
			instruction * inst = newInstruction(opcode_TEXS, $2.next, $3.next);
			
			int op;
			for(op = 0; op < inst->num_operands; op++) {
				if(inst->operands[op]->type == type_texture_operand) {
					break;
				}
			}
			
			//TODO figure out how to handle argument width
			
			$$.value = inst;
		}
	|	LEA mods operands
		{
			instruction * inst = newInstruction(opcode_LEA, $2.next, $3.next);
			$$.value = inst;
		}
	|	DSET mods {currentDouble = true;} operands
		{
			instruction* inst = newInstruction(opcode_DSET, $2.next, $4.next);
			$$.value = inst;
			
			//TODO confirm this needs to be done, and is all that needs to be done for this instruction:
			for(int x = 1; x < inst->num_operands; x++) {
				if(inst->operands[x]->reg >= 0) {
					inst->operands[x]->width = 2;
				}
			}
		}
	|	PHI mods operands
		{
			cerr << "FATAL ERROR py~1684: the input file is not permitted to include PHI instructions.\n";
			exit(0);
			//instruction * inst = newInstruction(opcode_PHI, $2.next, $3.next);
			//$$.value = inst;
		}
	|	BINCODE mods
		{
			instruction * inst = newInstruction(opcode_BINCODE, $2.next);
			$$.value = inst;
		}
;

%%

void yyerror(const char* s) {
	fprintf(stderr,"%s\n",s);
}

void stripSCHI() {
	node * iter = _blocks;
	while(iter) {
		blockNode* block = (blockNode*) iter->value;
		node * iter2 = block->instructions;
		
		//Delete SCHIs at beginning of block:
		while(iter2) {
			instruction* inst = (instruction*) iter2->value;
			if(inst->op == opcode_SCHI) {
				block->instructions = block->instructions->next;
				cleanInstruction(inst);
				free(iter2);
				iter2 = block->instructions;
			}
			else {
				break;
			}
		}
		
		//Delete SCHIs from second instruction on:
		while(iter2 && iter2->next) {
			instruction* inst = (instruction*) iter2->next->value;
			if(inst->op == opcode_SCHI) {
				cleanInstruction(inst);
				node * n = iter2->next;
				iter2->next = n->next;
				free(n);
				continue;
			}
			
			iter2 = iter2->next;
		}
		
		iter = iter->next;
	}
}

void insertSCHIs() {
	int instsPerSCHI;
	if(_arch < 50) {
		instsPerSCHI = 7;
	} else if(_arch < 70) {
		instsPerSCHI = 3;
	} else {
		cerr << "SANITY CHECK ERROR py~2132: unimplemented.\n";
		cerr << "\tNeed to check SCHI behavior on whatever architecture this is.\n";
		instsPerSCHI = 1;
	}
	
	/*
	int remainder = instsPerSCHI - ((_counter + 1) % instsPerSCHI);
	node * nLastBlock = _blocks;
	if(remainder != instsPerSCHI) {
		while(nLastBlock->next) nLastBlock = nLastBlock->next;
		while(remainder > 0) {
			blockNode * b = (blockNode *) nLastBlock->value;
			addLast(&b->instructions, newInstruction(opcode_NOP, 0));
			remainder--;
		}
	}*/
	
	instruction* currentSCHI = 0;
	int currentVal = 0;
	
	node * iter = _blocks;
	while(iter) {
		blockNode * block = (blockNode*) iter->value;
		node * iter2 = block->instructions;
		
		//We can stop if we reach an infinitely looping BRA in last block:
		if(!currentSCHI && block->branches && !block->branches->next && block->branches->value == block && !block->instructions->next) {
			break;
		}
		
		//Insert SCHI at block's start if appropriate:
		if(!currentSCHI) {
			node * operands = 0;
			for(int x = 0; x < instsPerSCHI; x++) {
				addFirst(&operands, newOperand(type_hex));
			}
			currentSCHI = newInstruction(opcode_SCHI, 0, operands);
			currentSCHI->SCHIVal = 0;
			currentVal = 0;
			addFirst(&block->instructions, currentSCHI);
		}
		
		while(iter2) {
			//Set SCHI value
			instruction * inst = (instruction*) iter2->value;
			currentSCHI->operands[currentVal]->val1 = inst->SCHIVal;
			if(_arch < 50) {
				//SCHI is either non-existent, or dispatch interval only
			} else if(_arch >= 50 && _arch < 70) {
				currentSCHI->operands[currentVal]->val1 |= (inst->depBarrierW << 5);
				currentSCHI->operands[currentVal]->val1 |= (inst->depBarrierR << 8);
				currentSCHI->operands[currentVal]->val1 |= (inst->depBarrierMask << 11);
				int firstOperand = 1;
				if(inst->op == opcode_MOV) firstOperand = 0;
				for(int x = firstOperand; x < inst->num_operands; x++) {
					if(inst->operands[x]->type != type_register && x == firstOperand) {
						firstOperand++;
					} else if(hasMod(inst->operands[x], "reuse")) {
						currentSCHI->operands[currentVal]->val1 |= (0x1 << (16 + (x + 1 - firstOperand)));
					}
				}
			} else {
				cerr << "ERROR: UNIMPLEMENTED py~2337\n";
				cerr << "\tNeed to add logic for handling scheduling metadata on this architecture.\n";
			}
			currentVal++;
			
			//Insert new SCHI if appropriate
			if(currentVal >= instsPerSCHI) {
				if(iter2->next || (_cuobjdump_version == 65 && _arch >= 50 && iter->next)) {
					node * operands = 0;
					for(int x = 0; x < instsPerSCHI; x++) {
						addFirst(&operands, newOperand(type_hex));
					}
					currentSCHI = newInstruction(opcode_SCHI, 0, operands);
					currentSCHI->SCHIVal = 0;
					currentVal = 0;
					
					node * newNode = (node*) malloc(sizeof(node));
					newNode->value = currentSCHI;
					newNode->next = iter2->next;
					iter2->next = newNode;
					iter2 = newNode;
				} else {//if possible, put SCHI at start of next block, as nvcc tends to do
					currentSCHI = 0;
				}
			}
			
			iter2 = iter2->next;
		}
		
		iter = iter->next;
	}
}

kernelData * generateByteCode() {
	kernelData * kern = (kernelData*) malloc(sizeof(kernelData));
	node * iter = _blocks;
	while(iter->next) {
		iter = iter->next;
	}
	
	kern->numBytes = ((blockNode*)iter->value)->address + ((blockNode*)iter->value)->size;
	kern->bytes = (char*) malloc(kern->numBytes);
	
	iter = _blocks;
	int addr = 0;
	while(iter) {
		blockNode * block = (blockNode*) iter->value;
		
		node * iter2 = block->instructions;
		while(iter2) {
			instruction* inst = (instruction*) iter2->value;
			
			char * hex = instructionToHexString(inst, _arch, _cuobjdump_version);
			if(inst->size == 8) {
				*((unsigned int*)&kern->bytes[addr]) = strtoull(hex, NULL, 16) >> 32;
				*((unsigned int*)&kern->bytes[addr+4]) = strtoull(hex+8, NULL, 16) & 0xffffffff;
			} else if(inst->size == 4) {
				*((unsigned int*)&kern->bytes[addr]) = strtoull(hex, NULL, 16) & 0xffffffff;//TODO test this
			}
			free(hex);
			
			addr += inst->size;
			iter2 = iter2->next;
		}
		
		iter = iter->next;
	}
	
	return kern;
}

node * getCallTargets() {
	node * targets = 0;
	node * iter = _functions;
	while(iter) {
		blockNode* block = (blockNode*) iter->value;
		addNode(&targets, (void*)(long long)block->address, &intorder);
		
		iter = iter->next;
	}
	return targets;
}

void initGlobalVariables() {
	_shared_memory = -1;
	_kernel_name = 0;
	_function_names = 0;
	_num_functions = 0;
	_functions = 0;
	
	_lastSCHI = 0;
	_lastSCHIVal = 0;
	_last_guard = 'z';
	_last_guard_neg = false;
	_just_branched = false;
	
	initBlock(&_currentBlock);
	_currentBlock->first = 0;
	_currentBlock->address = 0;
	_currentBlock->id = 0;
	_counter = 0;
	_addr = 0;
}

void finishParsing() {
	//Close up the last basic block:
	_currentBlock->last = _counter;
	if(_lastBlock) {
		addLast(&_lastBlock, (void*)_currentBlock);
		_lastBlock = _lastBlock->next;
	}
	else {
		addLast(&_blocks, (void*)_currentBlock);
		_lastBlock = _blocks;
	}
	
	//Fix up all the block successors:
	labelsToAddresses();
	propogateBranches(end_branch);
	propogateBranches(end_call);
	bool notDone = true;
	while(notDone) {
		notDone = false;
		notDone = notDone || propogatePointers();
		notDone = notDone || propogateCallReturns();
	}
	
	//Prepare addressing, in case it needs to be fixed later:
	setPtr();
	
	//Remove scheduling instructions, for easier analysis/modification of code.
	if(_lastSCHI) {
		stripSCHI();
	}
	fixAssembly();
}

int main(int argc, char ** argv) {
	bool flag_write = false;//true iff kernel function is written back to original file
	bool flag_stdin = false;//true iff kernel function is read from stdin
	bool flag_printCode = false;//true iff (modified) code will be printed to stdout
	bool flag_printBlocks = false;
	bool flag_fallbackelf = false;
	
	char* override_kernel_name = 0;
	
	int index_input = 0;//index in argv of input file name
	int index_elf = 0;//index in argv of elf file name
	
	//Read arguments:
	for(int x = 1; x < argc; x++) {
		if(!strcasecmp(argv[x],"-overrideName")) {
			x++;
			if(x >= argc) {
				fprintf(stderr,"ERROR: invalid arguments.\n");
				return 1;
			}
			override_kernel_name = strdup(argv[x]);
		} else if(!strcasecmp(argv[x],"-write")) {
			flag_write = true;
			index_elf = ++x;
			
			if(x >= argc) {
				fprintf(stderr,"ERROR: invalid arguments.\n");
				return 1;
			}
		} else if(!strcasecmp(argv[x],"-fallbackelf")) {
			flag_fallbackelf = true;
		} else if(!strcasecmp(argv[x],"-stdin")) {
			fprintf(stderr,"WARNING: -stdin flag deprecated.\n");
		} else if(!strcasecmp(argv[x],"-printCode")) {
			if(flag_printCode || flag_printBlocks) {
				fprintf(stderr,"ERROR: invalid arguments.\n");
				return 1;
			}
			flag_printCode = true;
		} else if(!strcasecmp(argv[x],"-printBlocks")) {
			if(flag_printCode || flag_printBlocks) {
				fprintf(stderr,"ERROR: invalid arguments.\n");
				return 1;
			}
			flag_printBlocks = true;
		} else if(!strcasecmp(argv[x],"-h")) {
			index_input = -1;
			break;
		} else if(!strcasecmp(argv[x],"-help")) {
			index_input = -1;
			break;
		} else if(!index_input && !flag_stdin) {
			index_input = x;
		} else {
			fprintf(stderr,"ERROR: invalid arguments.\n");
			return 1;
		}
	}
	
	if(argc >= 2 && index_input == 0) {
		flag_stdin = true;
	}
	
	//Execute special actions depending on arguments:
	if(index_input < 0 || (!index_input && !flag_stdin)) {
		cout << "Usage: " << argv[0] << " [options] <input-file>\n";
		cout << "Options:\n";
		cout << "-write <elf-file>\n";
		cout << "\tRewrite kernel to file.\n";
		cout << "-stdin\n";
		cout << "\tRead input from stdin instead of from file.\n";
		cout << "-printCode\n";
		cout << "\tPrints final assembly code to stdout.\n";
		cout << "\tOnly use one -print flag.\n";
		cout << "-printBlocks\n";
		cout << "\tPrints final assembly code's basic blocks to stdout.\n";
		cout << "\tOnly use one -print flag.\n";
		cout << "-h, -help\n";
		cout << "\tDisplay this help, and then exit.\n";
		return 0;
	}
	
	//Set input source:
	if(!flag_stdin) {
		yyin = fopen(argv[index_input], "r");
	}
	else {
		yyin = stdin;
	}
	
	//Check if input file exists:
	if(!yyin) {
		fprintf(stderr,"ERROR: requires valid input file.\n");
		return 0;
	}
	
	//Parse input file:
	initGlobalVariables();
	yyparse();
	finishParsing();
	
	//Cleanup after parsing:
	if(!flag_stdin) {
		fclose(yyin);
	}
	yylex_destroy();
	
	if(override_kernel_name) {
		free(_kernel_name);
		_kernel_name = override_kernel_name;
	}
	
	//This is where we might call functions to modify or optimize the GPU code.
	
	if(flag_printBlocks) {
		//removeExtraNOPs();
		fixAssembly();
		combineBlocks();
		fixAssembly();
		addressesToLabels();
		printfBlocks(true);
	} else {
		//removeExtraNOPs();
		fixAssembly();
	}
	
	if(_arch >= 30) {//SCHI codes were stripped; need to reinsert them
		insertSCHIs();
		fixAssembly();
	}
	if(flag_printCode) {
		printfAssembly(true);
	}
	
	if(flag_write) {
		if(_arch == 20 || _arch == 21 || _arch == 30) {
			if(_num_registers > 63) {
				cerr << "FATAL ERROR: Attempting to generate binary with out-of-bounds register IDs.\n";
				exit(0);
			}
		} else if(_arch > 30 || _arch < 70) {
			if(_num_registers > 255) {
				cerr << "FATAL ERROR: Attempting to generate binary with out-of-bounds register IDs.\n";
				exit(0);
			}
		} else {
			cerr << "FATAL ERROR: Attempting to generate binary for unrecognized architecture.\n";
			exit(0);
		}
		if(_kernel_name) {
			kernelData * kern = generateByteCode();
			kern->name = _kernel_name;
			kern->arch = _arch;
			kern->numRegisters = _num_registers;
			kern->sharedMemory = _shared_memory;
			kern->min_stack_size = _min_stack_size;
			kern->max_stack_size = _max_stack_size;
			kern->frame_size = _frame_size;
			node * callTargets = getCallTargets();
			
			if(!overwriteKernel(argv[index_elf], kern, callTargets, flag_fallbackelf)) {
				cerr << "FATAL ERROR; unable to modify the binary.\n";
				exit(0);
			}
			
			cleanNodes(callTargets);
			free(kern->bytes);
			free(kern);
		} else {
			cerr << "FATAL ERROR: Kernel function name unknown; cannot modify the binary.\n";
			exit(0);
		}
	}
	
	//Cleanup and exit:
	cleanNodesFully(_blocks, (void (*)(void*))&cleanBlock);
	if(_kernel_name) {
		free(_kernel_name);
	}
	cleanNodes(_functions);
	for(int x = 0; x < _num_functions; x++) {
		free(_function_names[x]);
	}
	if(_function_names) {
		free(_function_names);
	}
	
	return 0;
}

